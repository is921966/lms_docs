---
description:
globs:
alwaysApply: false
---
# Client-Server Integration Guidelines

## API Contract Definition

### Clear API Contracts
–û–±–µ—Å–ø–µ—á—å—Ç–µ —á–µ—Ç–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç –º–µ–∂–¥—É –∫–ª–∏–µ–Ω—Ç–æ–º –∏ —Å–µ—Ä–≤–µ—Ä–æ–º:
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ OpenAPI/Swagger —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è API
- –í–µ—Ä—Å–∏–æ–Ω–∏—Ä—É–π—Ç–µ API –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
- –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –≤—Å–µ endpoints, –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –∏ —Ñ–æ—Ä–º–∞—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤
- –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–π—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ–∂–¥—É frontend –∏ backend –∫–æ–º–∞–Ω–¥–∞–º–∏

### OpenAPI Specification Example
```yaml
openapi: 3.0.0
info:
  title: LMS API
  version: 1.0.0
paths:
  /api/v1/auth/login:
    post:
      summary: User authentication
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/LoginRequest'
      responses:
        '200':
          description: Successful authentication
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LoginResponse'
        '401':
          description: Invalid credentials
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'
```

## Data Transfer Objects (DTO) Pattern

### Separate API Models from Domain
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ DTO –¥–ª—è —Å–µ—Ç–µ–≤–æ–≥–æ –æ–±–º–µ–Ω–∞ –¥–∞–Ω–Ω—ã–º–∏:
```swift
// Infrastructure/Network/DTOs/UserDTO.swift
struct UserDTO: Codable {
    let id: String
    let email: String
    let fullName: String
    let createdAt: String
    
    enum CodingKeys: String, CodingKey {
        case id
        case email
        case fullName = "full_name"
        case createdAt = "created_at"
    }
}

// Domain/Entities/User.swift
struct User {
    let id: UUID
    let email: Email
    let name: PersonName
    let registrationDate: Date
}
```

### DTO Benefits
- –ò–∑–æ–ª—è—Ü–∏—è domain –º–æ–¥–µ–ª–∏ –æ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π API
- –ì–∏–±–∫–æ—Å—Ç—å –≤ –º–∞–ø–ø–∏–Ω–≥–µ –ø–æ–ª–µ–π (snake_case ‚Üí camelCase)
- –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ API –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è domain
- –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ —Å–∏—Å—Ç–µ–º—ã

## Mappers and Adapters

### Clean Mapping Layer
–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–ª–æ–π –∞–¥–∞–ø—Ç–µ—Ä–æ–≤ –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö:
```swift
// Application/Mappers/UserMapper.swift
protocol UserMapperProtocol {
    func toDomain(_ dto: UserDTO) throws -> User
    func toDTO(_ user: User) -> UserDTO
}

final class UserMapper: UserMapperProtocol {
    private let dateFormatter: ISO8601DateFormatter
    
    init() {
        self.dateFormatter = ISO8601DateFormatter()
    }
    
    func toDomain(_ dto: UserDTO) throws -> User {
        guard let uuid = UUID(uuidString: dto.id),
              let email = try? Email(dto.email),
              let date = dateFormatter.date(from: dto.createdAt) else {
            throw MappingError.invalidData
        }
        
        return User(
            id: uuid,
            email: email,
            name: PersonName(fullName: dto.fullName),
            registrationDate: date
        )
    }
    
    func toDTO(_ user: User) -> UserDTO {
        UserDTO(
            id: user.id.uuidString,
            email: user.email.value,
            fullName: user.name.fullName,
            createdAt: dateFormatter.string(from: user.registrationDate)
        )
    }
}
```

### Mapper Location
- –ê–¥–∞–ø—Ç–µ—Ä—ã —Ä–∞—Å–ø–æ–ª–∞–≥–∞—é—Ç—Å—è –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ö —Å–ª–æ–µ–≤
- –ß–∏—Å—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –ø–æ–±–æ—á–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
- –¢–µ—Å—Ç–∏—Ä—É–µ–º—ã–µ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Å–µ—Ç–∏/–ë–î

## Error Handling

### Centralized Error Processing
–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –æ—à–∏–±–∫–∏ –∏ —Å–±–æ–∏ —Å–µ—Ç–∏ —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ:
```swift
// Domain/Errors/AppError.swift
enum AppError: Error {
    case network(NetworkError)
    case authentication(AuthError)
    case validation(ValidationError)
    case server(ServerError)
    case unknown(Error)
}

enum NetworkError: Error {
    case noConnection
    case timeout
    case invalidURL
}

enum ServerError: Error {
    case internalError(code: Int)
    case maintenance
    case unavailable
}

// Infrastructure/Network/ErrorMapper.swift
final class ErrorMapper {
    func mapError(_ error: Error, response: HTTPURLResponse?) -> AppError {
        if let response = response {
            switch response.statusCode {
            case 401:
                return .authentication(.invalidCredentials)
            case 403:
                return .authentication(.accessDenied)
            case 400...499:
                return .validation(.invalidRequest)
            case 500...599:
                return .server(.internalError(code: response.statusCode))
            default:
                break
            }
        }
        
        if (error as NSError).code == NSURLErrorNotConnectedToInternet {
            return .network(.noConnection)
        }
        
        if (error as NSError).code == NSURLErrorTimedOut {
            return .network(.timeout)
        }
        
        return .unknown(error)
    }
}
```

### User-Friendly Error Messages
```swift
extension AppError {
    var userMessage: String {
        switch self {
        case .network(.noConnection):
            return "–ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ."
        case .network(.timeout):
            return "–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        case .authentication(.invalidCredentials):
            return "–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å."
        case .server(.maintenance):
            return "–°–µ—Ä–≤–µ—Ä –Ω–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–º –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–∏."
        default:
            return "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        }
    }
}
```

## Network Client Abstraction

### Protocol-Based Design
–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ —Å–ª–∞–±—É—é —Å–≤—è–∑–∞–Ω–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã:
```swift
// Domain/Repositories/NetworkClientProtocol.swift
protocol NetworkClientProtocol {
    func request<T: Decodable>(
        _ endpoint: Endpoint
    ) async throws -> T
    
    func upload(
        _ data: Data,
        to endpoint: Endpoint
    ) async throws -> UploadResponse
}

// Infrastructure/Network/URLSessionNetworkClient.swift
final class URLSessionNetworkClient: NetworkClientProtocol {
    private let session: URLSession
    private let baseURL: URL
    private let interceptors: [NetworkInterceptor]
    
    init(
        session: URLSession = .shared,
        baseURL: URL,
        interceptors: [NetworkInterceptor] = []
    ) {
        self.session = session
        self.baseURL = baseURL
        self.interceptors = interceptors
    }
    
    func request<T: Decodable>(
        _ endpoint: Endpoint
    ) async throws -> T {
        let request = try buildRequest(for: endpoint)
        let modifiedRequest = try await applyInterceptors(request)
        
        let (data, response) = try await session.data(for: modifiedRequest)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        
        try validateResponse(httpResponse, data: data)
        
        return try JSONDecoder().decode(T.self, from: data)
    }
}
```

### Endpoint Definition
```swift
// Infrastructure/Network/Endpoints/Endpoint.swift
protocol Endpoint {
    var path: String { get }
    var method: HTTPMethod { get }
    var headers: [String: String]? { get }
    var parameters: [String: Any]? { get }
    var body: Data? { get }
}

// Infrastructure/Network/Endpoints/UserEndpoints.swift
enum UserEndpoint: Endpoint {
    case profile(userId: String)
    case updateProfile(userId: String, data: UpdateProfileDTO)
    case deleteAccount(userId: String)
    
    var path: String {
        switch self {
        case .profile(let id), .updateProfile(let id, _), .deleteAccount(let id):
            return "/users/\(id)"
        }
    }
    
    var method: HTTPMethod {
        switch self {
        case .profile:
            return .get
        case .updateProfile:
            return .put
        case .deleteAccount:
            return .delete
        }
    }
    
    var body: Data? {
        switch self {
        case .updateProfile(_, let data):
            return try? JSONEncoder().encode(data)
        default:
            return nil
        }
    }
}
```

## Request/Response Interceptors

### Chain of Responsibility Pattern
```swift
// Infrastructure/Network/Interceptors/NetworkInterceptor.swift
protocol NetworkInterceptor {
    func intercept(_ request: URLRequest) async throws -> URLRequest
    func intercept(_ response: URLResponse, data: Data) async throws -> (URLResponse, Data)
}

// Authentication Interceptor
final class AuthInterceptor: NetworkInterceptor {
    private let tokenProvider: TokenProviderProtocol
    
    func intercept(_ request: URLRequest) async throws -> URLRequest {
        var modifiedRequest = request
        
        if let token = await tokenProvider.getAccessToken() {
            modifiedRequest.setValue(
                "Bearer \(token)",
                forHTTPHeaderField: "Authorization"
            )
        }
        
        return modifiedRequest
    }
    
    func intercept(_ response: URLResponse, data: Data) async throws -> (URLResponse, Data) {
        if let httpResponse = response as? HTTPURLResponse,
           httpResponse.statusCode == 401 {
            try await tokenProvider.refreshToken()
            throw NetworkError.tokenExpired // Retry with new token
        }
        
        return (response, data)
    }
}

// Logging Interceptor
final class LoggingInterceptor: NetworkInterceptor {
    func intercept(_ request: URLRequest) async throws -> URLRequest {
        Logger.network.debug("üåê Request: \(request.url?.absoluteString ?? "")")
        return request
    }
    
    func intercept(_ response: URLResponse, data: Data) async throws -> (URLResponse, Data) {
        if let httpResponse = response as? HTTPURLResponse {
            Logger.network.debug("‚úÖ Response: \(httpResponse.statusCode)")
        }
        return (response, data)
    }
}
```

## Caching Strategy

### HTTP Cache
```swift
// Infrastructure/Network/Cache/HTTPCache.swift
protocol HTTPCacheProtocol {
    func cache(response: CachedResponse, for request: URLRequest)
    func getCachedResponse(for request: URLRequest) -> CachedResponse?
    func removeCachedResponse(for request: URLRequest)
    func removeAllCachedResponses()
}

struct CachedResponse {
    let data: Data
    let response: URLResponse
    let timestamp: Date
    let maxAge: TimeInterval
    
    var isExpired: Bool {
        Date().timeIntervalSince(timestamp) > maxAge
    }
}
```

### Cache Policy
```swift
enum CachePolicy {
    case networkOnly
    case cacheFirst
    case networkFirst
    case cacheOnly
    case custom(TimeInterval)
}

extension NetworkClientProtocol {
    func request<T: Decodable>(
        _ endpoint: Endpoint,
        cachePolicy: CachePolicy = .networkOnly
    ) async throws -> T {
        // Implementation with cache logic
    }
}
```

## Offline Support

### Queue for Offline Requests
```swift
// Infrastructure/Network/OfflineQueue.swift
protocol OfflineQueueProtocol {
    func enqueue(_ request: OfflineRequest)
    func processQueue() async
    func getPendingRequests() -> [OfflineRequest]
}

struct OfflineRequest: Codable {
    let id: UUID
    let endpoint: String
    let method: String
    let body: Data?
    let timestamp: Date
    let retryCount: Int
}

final class OfflineQueue: OfflineQueueProtocol {
    @Published private(set) var pendingRequests: [OfflineRequest] = []
    private let storage: UserDefaults
    private let networkMonitor: NetworkMonitorProtocol
    
    func enqueue(_ request: OfflineRequest) {
        pendingRequests.append(request)
        saveToDisk()
        
        Task {
            if networkMonitor.isConnected {
                await processQueue()
            }
        }
    }
}
```

## API Versioning

### Version Management
```swift
enum APIVersion: String {
    case v1 = "v1"
    case v2 = "v2"
    
    var basePath: String {
        "/api/\(rawValue)"
    }
}

// Usage
let endpoint = "\(APIVersion.v1.basePath)/users"
```

### Backward Compatibility
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ API –º–∏–Ω–∏–º—É–º 6 –º–µ—Å—è—Ü–µ–≤
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ deprecation warnings –≤ headers
- –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ migration guide –¥–ª—è –Ω–æ–≤—ã—Ö –≤–µ—Ä—Å–∏–π

## Testing Network Layer

### Mock Network Client
```swift
final class MockNetworkClient: NetworkClientProtocol {
    var mockResponses: [String: Result<Data, Error>] = [:]
    var requestCallCount = 0
    var lastRequest: Endpoint?
    
    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {
        requestCallCount += 1
        lastRequest = endpoint
        
        guard let result = mockResponses[endpoint.path] else {
            throw NetworkError.notFound
        }
        
        switch result {
        case .success(let data):
            return try JSONDecoder().decode(T.self, from: data)
        case .failure(let error):
            throw error
        }
    }
}
```

## AI Generation Guidelines

When generating network code:

1. **Always use DTOs** - never expose domain models to network layer
2. **Implement proper error handling** - map all errors to app-specific types
3. **Use protocols** for testability and flexibility
4. **Add interceptors** for cross-cutting concerns
5. **Consider offline scenarios** - queue requests when offline
6. **Version your APIs** properly
7. **Write comprehensive tests** including error cases

Remember: The network layer is a critical boundary - keep it clean, testable, and resilient to changes.
